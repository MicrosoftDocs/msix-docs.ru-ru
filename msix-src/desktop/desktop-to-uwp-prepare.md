---
Description: В этой статье перечислены вещи, которые необходимо знать перед упаковкой приложения для настольных систем. Подготовка приложения к процессу упаковки, как правило, не требует больших усилий.
title: Подготовка к упаковке классического приложения (MSIX)
ms.date: 08/22/2019
ms.topic: article
keywords: windows 10, uwp, msix
ms.assetid: 71a57ca2-ca00-471d-8ad9-52f285f3022e
ms.localizationpriority: medium
ms.openlocfilehash: 3dde98d7e5d92b3f3e9fe3afe5dc5eb9485f7b57
ms.sourcegitcommit: 0412ba69187ce791c16313d0109a5d896141d44c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75303287"
---
# <a name="prepare-to-package-a-desktop-application"></a>Подготовка к упаковке классического приложения

В этой статье перечислены вещи, которые необходимо знать перед упаковкой приложения для настольных систем. Вам может не потребоваться много усилий, чтобы приложение было готово к процессу упаковки, но если какой бы то ни было из приведенных ниже элементов применимо к вашему приложению, необходимо устранить его перед упаковкой. Не забывайте, что лицензирование и автоматическое обновление вашего приложения обеспечивается Microsoft Store, поэтому любые возможности, относящиеся к этим задачам, можно исключить из вашей базы кода.

+ Для __приложения .NET требуется версия .NET Framework более раннюю, чем 4.6.2__. При упаковке приложения .NET рекомендуется, чтобы целевой объект приложения .NET Framework 4.6.2 или более поздней версии. Возможность установки и запуска упакованных классических приложений впервые появилась в Windows 10, версия 1607 (также именуемая обновлением годовщины), а эта версия ОС включает .NET Framework 4.6.2 по умолчанию. Более поздние версии ОС включают в себя более поздние версии .NET Framework. Полный список версий .NET, которые входят в состав более поздних версий Windows 10, см. в [этой статье](https://docs.microsoft.com/dotnet/framework/migration-guide/versions-and-dependencies).

  В большинстве случаев рекомендуется использовать целевые версии .NET Framework более ранние, чем 4.6.2 в упакованных настольных приложениях. Однако если вы нацелены на более раннюю версию, чем 4.6.2, следует полностью протестировать упакованное настольное приложение перед его распространением пользователям.

  + 4,0-4.6.1: приложения, предназначенные для этих версий .NET Framework, должны выполняться без проблем в 4.6.2 или более поздней версии. Поэтому эти приложения должны устанавливаться и работать без изменений в Windows 10, версии 1607 или более поздней с версией .NET Framework, которая входит в состав операционной системы.

  + 2,0 и 3,5: в нашем тестировании Упакованные классические приложения, предназначенные для этих версий .NET Framework, обычно работают, но могут демонстрировать проблемы с производительностью в некоторых сценариях. Чтобы эти Упакованные приложения могли устанавливаться и запускаться, на целевом компьютере должен быть установлен [компонент .NET Framework 3,5](https://docs.microsoft.com/dotnet/framework/install/dotnet-35-windows-10) (этот компонент также включает .NET Framework 2,0 и 3,0). Следует также тщательно протестировать эти приложения после их упаковки.

+ __Приложение всегда запускается с повышенными привилегиями безопасности__. Приложение должно работать при запуске от имени интерактивного пользователя. Пользователи, которые устанавливают приложение из Microsoft Store, могут быть не системными администраторами, поэтому, чтобы приложение могло работать с повышенными правами, оно не будет правильно работать для обычных пользователей. Приложения, требующие повышения прав для любой своей функций, не будут приняты в Microsoft Store.

+ __Для приложения требуется драйвер режима ядра или служба Windows__. Мост для настольных систем подходит для приложения, но не поддерживает драйвер режима ядра или службу Windows, которая должна работать под системной учетной записью. Вместо службы Windows используйте [фоновую задачу](/windows/uwp/launch-resume/create-and-register-a-background-task).

+ __Модули вашего приложения загружаются во внутрипроцессном режиме в процессы, которые отсутствуют в пакете приложения для Windows__. Это запрещено и означает, что внутрипроцессные расширения, такие как [расширения оболочки](https://msdn.microsoft.com/library/windows/desktop/dd758089.aspx), не поддерживаются. Но если у вас есть два приложения в одинаковом пакете, вы можете настроить межпроцессное взаимодействие между ними.

+ __Приложение использует идентификатор пользовательской модели пользовательского приложения (AUMID)__ . Если процесс вызывает [сеткуррентпроцессексплиЦитаппусермоделид](https://msdn.microsoft.com/library/windows/desktop/dd378422.aspx) для установки собственного AUMID, то он может использовать только AUMID, созданный для него в пакете модели приложения или пакета приложения Windows. Вы не можете определять пользовательские AUMID.

+ __Приложение изменяет куст реестра HKEY_LOCAL_MACHINE (HKLM)__ . Любая попытка приложения создать ключ HKLM или открыть его для изменения приведет к ошибке отказа в доступе. Помните, что приложение имеет собственное виртуальное представление реестра, так что понятие куста реестра на уровне пользователя и компьютера (то есть HKLM) не применяется. Потребуется найти другой способ достичь того, чего требовалось при использовании HKLM, например запись в HKEY_CURRENT_USER (HKCU).

+ __Приложение использует подраздел реестра ддиксек в качестве средства запуска другого приложения__. Вместо этого используйте один из обработчиков команды DelegateExecute в соответствии с настройками различных расширений Activatable* в вашем [манифесте пакета приложения](https://msdn.microsoft.com/library/windows/apps/br211474.aspx).

+ __Приложение записывает данные в папку AppData или в реестр с намерением обмениваться данными с другим приложением__. После преобразования AppData будет перенаправлен в локальное хранилище данных приложений, которое является частным хранилищем для каждого приложения.

  Все записи, записываемые приложением в куст реестра HKEY_LOCAL_MACHINE, перенаправляются в изолированный двоичный файл, а все записи, записываемые приложением в куст реестра HKEY_CURRENT_USER, помещаются в личное расположение на уровне пользователя или приложения. Дополнительные сведения о перенаправлении файлов и реестра см. в разделе [Как работает мост для классических приложений](desktop-to-uwp-behind-the-scenes.md).  

  Используйте другие средства межпроцессного обмена данными. Подробнее: [Хранение и извлечение параметров и прочих данных приложения](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data).

+ __Приложение записывает в каталог установки приложения__. Например, приложение записывает в файл журнала, который вы поместили в тот же каталог, что и ваш файл exe. Эта операция не поддерживается, поэтому потребуется найти другое расположение, например, локальное хранилище данных приложения.

+ __Приложение использует текущий рабочий каталог__. Во время выполнения упакованное настольное приложение не будет иметь тот же рабочий каталог, который был ранее указан на рабочем столе. Ярлык LNK. Необходимо изменить КВД во время выполнения, если для правильного функционирования приложения важен правильный каталог.

  > [!NOTE]
  > Если приложению требуется выполнить запись в каталог установки или использовать текущий рабочий каталог, можно также добавить исправление среды выполнения с помощью [платформы поддержки пакетов](https://github.com/microsoft/MSIX-PackageSupportFramework) в пакет. Дополнительные сведения см. в [этой статье](../psf/package-support-framework.md). 

+ Для __установки приложения требуется вмешательство пользователя__. Установщик приложения должен иметь возможность запускаться автоматически, и он должен установить все необходимые компоненты, которые не включены по умолчанию на чистом образе ОС.

+ __Приложению требуется UIAccess__. Если в приложении указано `UIAccess=true` в элементе `requestedExecutionLevel` манифеста UAC, в настоящее время преобразование в MSIX не поддерживается. Подробнее см. в разделе [Обзор системы безопасности модели автоматизации пользовательского интерфейса](https://msdn.microsoft.com/library/ms742884.aspx).

+ __Приложение предоставляет COM-объекты__. Процессы и расширения из пакета могут регистрировать и использовать серверы COM и OLE, как внутрипроцессные, так и внепроцессные (OOP).  Creators Update добавляет поддержку технологии Packaged COM, позволяющей регистрировать серверы OOP COM и OLE, которые видимы за пределами пакета.  См. раздел [Поддержка сервера COM и документа OLE для моста для классических приложений](https://blogs.windows.com/windowsdeveloper/2017/04/13/com-server-ole-document-support-desktop-bridge).

   Технология Packaged COM поддерживает работу с существующими API модели COM, но не будет работать для расширений приложения, которые зависят от чтения реестра напрямую, так как расположение для Packaged COM находится в частном расположении.

+ __Приложение предоставляет сборки GAC для использования другими процессами__. В текущем выпуске приложение не может предоставлять сборки GAC для использования процессами, выполняемыми из исполняемых файлов, которые являются внешними по отношению к пакету приложения Windows. Процессы из пакета могут регистрировать и использовать сборки GAC обычным образом, но они не будут видны извне. Это означает, что сценарии межпрограммного взаимодействия (например, OLE) не будут работать при их вызове внешними процессами.

+ __Приложение не поддерживает связывание библиотек времени выполнения C (CRT)__ . Библиотека времени выполнения C/C++ Майкрософт предоставляет процедуры для программирования в среде операционной системы Microsoft Windows. Эти процедуры автоматизируют выполнение многих распространенных задач программирования, которые не предоставляются языками C и C++. Если приложение использует библиотеку C/C++ Runtime, необходимо обеспечить его связь поддерживаемым способом.

    Visual Studio 2017 поддерживает как динамическое связывание, чтобы код мог использовать общие файлы DLL, так и статическое связывание для связывания библиотеки непосредственно с кодом, до текущей версии CRT. По возможности мы рекомендуем использовать в приложении динамическую компоновку с VS 2017.

    Поддержка различных типов связывания зависит от версии Visual Studio. Подробности см. в следующей таблице:

    <table>
    <th>Версия Visual Studio</td><th>Динамическое связывание</th><th>Статическое связывание</th></th>
    <tr><td>2005 (VC 8)</td><td>Не поддерживается.</td><td>Поддерживается</td>
    <tr><td>2008 (VC 9)</td><td>Не поддерживается.</td><td>Поддерживается</td>
    <tr><td>2010 (VC 10)</td><td>Поддерживается</td><td>Поддерживается</td>
    <tr><td>2012 (VC 11)</td><td>Поддерживается</td><td>Не поддерживается.</td>
    <tr><td>2013 (VC 12)</td><td>Поддерживается</td><td>Не поддерживается.</td>
    <tr><td>2015 и 2017 (VC 14)</td><td>Поддерживается</td><td>Поддерживается</td>
    </table>

    Примечание. во всех случаях необходимо создать ссылку на последнюю общедоступную CRT.

+ __Приложение устанавливает и загружает сборки из параллельной папки Windows__. Например, приложение использует библиотеки среды выполнения C VC8 или VC9 и динамически связывает их из параллельной папки Windows, что означает, что код использует общие DLL-файлы из общей папки. Такой способ связывания не поддерживается. Необходимо подключать их статически, то есть связать с распространяемыми файлами библиотеки непосредственно в самом коде.

+ __Приложение использует зависимость в папке System32/SysWOW64__. Чтобы эти DLL-файлы начали работать, необходимо включить их в часть вашего пакета приложения для Windows, находящуюся в виртуальной файловой системе. Это гарантирует, что приложение ведет себя так, как если бы библиотеки DLL были установлены в папку **System32**/**SysWOW64** . В корне пакета создайте папку с именем **VFS**. В этой папке создайте папки **SystemX64** и **SystemX86**. Затем поместите 32-разрядную версию DLL-файла в папку **SystemX86**, а 64-разрядную версию — в папку **SystemX64**.

+ __Ваше приложение использует пакет платформы VCLibs__. При преобразовании приложения C++ Win32 необходимо выполнять развертывание среды выполнения Visual C++ . Visual Studio 2019 и Windows SDK включают последние пакеты платформы для версии 11,0, 12,0 и 14,0 среды выполнения Visual C++ в следующих папках:

    * **Пакеты платформы VC 14,0**: C:\Program Files (x86) \Microsoft SDKs\Windows Kits\10\ExtensionSDKs\Microsoft.VCLibs.Desktop\14.0

    * **Пакеты платформы VC 12,0**: C:\Program Files (x86) \Microsoft SDKs\Windows Kits\10\ExtensionSDKs\Microsoft.VCLibs.Desktop.120\14.0

    * **Пакеты платформы VC 11,0**: C:\Program Files (x86) \Microsoft SDKs\Windows Kits\10\ExtensionSDKs\Microsoft.VCLibs.Desktop.110\14.0

    Чтобы использовать один из этих пакетов, необходимо сослаться на пакет как зависимость в манифесте пакета. Когда клиенты устанавливают розничную версию приложения из Microsoft Store, пакет будет установлен из магазина вместе с приложением. При загрузке приложения зависимости не будут установлены. Чтобы установить зависимости вручную, необходимо установить соответствующий пакет платформы с помощью соответствующего appx-пакета для x86, x64 или ARM, расположенного в перечисленных выше папках установки.

    Для ссылки на пакет C++ платформы среды выполнения Visual Runtime в приложении:

    1. Перейдите в папку установки пакета платформы, указанную выше, для версии среды выполнения C++ Visual, используемой приложением.

    2. Откройте файл SDKManifest. XML в этой папке, перейдите к атрибуту `FrameworkIdentity-Debug` или `FrameworkIdentity-Retail` (в зависимости от того, используете ли вы отладочную или розничную версию среды выполнения), и скопируйте значения `Name` и `MinVersion` из этого атрибута. Например, ниже приведен атрибут `FrameworkIdentity-Retail` для текущего пакета платформы VC 14,0.
        ```xml
        FrameworkIdentity-Retail = "Name = Microsoft.VCLibs.140.00.UWPDesktop, MinVersion = 14.0.27323.0, Publisher = 'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'"
        ```

    3. В манифесте пакета для приложения добавьте следующий элемент `<PackageDependency>` в узел `<Dependencies>`. Убедитесь, что `Name` и `MinVersion` значения заменяются значениями, скопированными на предыдущем шаге. В следующем примере задается зависимость для текущей версии пакета платформы VC 14,0.
        ```xml
        <PackageDependency Name="Microsoft.VCLibs.140.00.UWPDesktop" MinVersion="14.0.27323.0" Publisher="CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US" />
        ```

+ __Приложение содержит пользовательский список переходов__. Списки переходов следует использовать с учетом некоторых оговорок и условий.

    - __Архитектура вашего приложения не соответствует операционной системе.__  Списки переходов в настоящее время не работают правильно, если архитектуры приложения и ОС не совпадают (например, приложение x86 работает в Windows x64). В настоящее время не существует обходного решения, кроме перекомпиляции приложения в соответствующую архитектуру.

    - __Приложение создает записи списка переходов и вызывает [икустомдестинатионлист:: Сетаппид](https://msdn.microsoft.com/library/windows/desktop/dd378403(v=vs.85).aspx) или [сеткуррентпроцессексплиЦитаппусермоделид](https://msdn.microsoft.com/library/windows/desktop/dd378422(v=vs.85).aspx)__ . Не задавайте свой AppID в коде программными средствами. Это приведет к тому, что элементы списка переходов не будут отображаться. Если приложению требуется пользовательский идентификатор, укажите его с помощью файла манифеста. Инструкции см. в разделе [Упаковка приложения для настольных компьютеров вручную](desktop-to-uwp-manual-conversion.md) . AppID для вашего приложения указан в разделе *YOUR_PRAID_HERE*.

    - __Приложение добавляет ссылку оболочки списка переходов, которая ссылается на исполняемый файл в пакете__. Напрямую запускать исполняемые файлы в пакете из списка переходов нельзя (за исключением абсолютного пути собственного файла .exe приложения). Вместо этого зарегистрируйте псевдоним выполнения приложения (который позволяет упакованному настольному приложению начать с помощью ключевого слова, как будто оно было на пути) и задайте вместо этого путь к целевому пути ссылки. Дополнительные сведения об использовании расширения Аппексекутионалиас см. в статье [Интеграция классического приложения с Windows 10](https://docs.microsoft.com/windows/apps/desktop/modernize/desktop-to-uwp-extensions). Обратите внимание, что если требуется, чтобы ресурсы ссылки в списке переходов совпадали с исходным файлом .exe, необходимо задать ресурсы, такие как значок, используя [**SetIconLocation**](https://msdn.microsoft.com/library/windows/desktop/bb761047(v=vs.85).aspx), а для отображения имени использовать PKEY_Title, так же, как и для других пользовательских записей.

    - __Приложение добавляет записи списка переходов, которые ссылаются на ресурсы в пакете приложения по абсолютным путям__. Путь установки приложения может измениться при обновлении его пакетов, изменив расположение ресурсов (например, значки, документы, исполняемые файлы и т. д.). Если записи списка переходов ссылаются на такие ресурсы по абсолютным путям, то приложение должно периодически обновлять список переходов (например, при запуске приложения), чтобы обеспечить правильное разрешение путей. Либо можно использовать API-интерфейсы UWP [**Windows.UI.StartScreen.JumpList**](https://msdn.microsoft.com/library/windows/apps/windows.ui.startscreen.jumplist.aspx), которые позволяют ссылаться на ресурсы строк и изображений с помощью схемы URI package-relative ms-resource (которая также поддерживает определение языка, DPI и высокой контрастности).

+ __Приложение запускает программу для выполнения задач__. Избегайте запуска служебных программ командной строки, таких как PowerShell и Cmd.exe. На самом деле, если пользователи устанавливают приложение в систему под управлением Windows 10 S, приложение не сможет запускать их вообще. Это может препятствовать отправке приложения в Microsoft Store, так как все приложения, отправляемые в Microsoft Store, должны быть совместимы с Windows 10 S.

Служебные программы часто предоставляют удобный способ для получения информации из операционной системы, доступа к реестру или к возможностям системы. Однако для выполнения такого рода задач можно использовать API UWP. Эти API являются более производительными, так как им не нужен отдельный исполняемый файл, но, что более важно, они позволяют приложению достичь вне пакета. Структура приложения остается согласованной с изоляцией, доверием и безопасностью, которая поставляется с приложением, которое было упаковано, и ваше приложение будет работать так, как ожидается, в системах под Windows 10 S.

+ __В приложении размещаются надстройки, подключаемые модули или расширения__.   Во многих случаях расширения в стиле COM устанавливаются как расширения с полным доверием, и, скорее всего, они будут работать до тех пор, пока не будут упакованы. Это обусловлено тем, что эти установщики могут использовать свои возможности полного доверия для изменения реестра и размещения файлов расширений везде, где приложение должно их найти.

   Однако если эти расширения упакованы, а затем установлены как пакет приложения Windows, они не будут работать, так как каждый пакет (ведущее приложение и расширение) будет изолирован друг от друга. Дополнительные сведения о том, как приложения изолированы от системы, см. в разделе в фоновом режиме [моста рабочего стола](desktop-to-uwp-behind-the-scenes.md).

 Все приложения и расширения, которые устанавливаются пользователями в системе под управлением Windows 10 S, должны устанавливаться в виде пакетов приложений для Windows. Поэтому, если вы планируете упаковать расширения или хотите, чтобы участники могли их упаковать, подумайте, как можно упростить обмен данными между пакетом ведущего приложения и любыми пакетами расширений. Вы можете сделать это, например, с помощью [службы приложений](https://docs.microsoft.com/windows/uwp/launch-resume/app-services).

+ __Приложение создает код__. Приложение может генерировать код, который он использует в памяти, но не писать созданный код на диск, поскольку процесс сертификации приложений Windows не может проверить этот код до отправки приложения. Кроме того, приложения, которые пишут код на диск, не будут правильно работать в системах под управлением Windows 10 S. Это может препятствовать отправке приложения в Microsoft Store, так как все приложения, отправляемые в Microsoft Store, должны быть совместимы с Windows 10 S.

>[!IMPORTANT]
> После создания пакета приложения Windows проверьте приложение, чтобы убедиться, что оно правильно работает в системах под управлением Windows 10 S. Все приложения, отправленные в Microsoft Store, должны быть совместимы с Windows 10 S. приложения, которые не совместимы, не будут приниматься в хранилище. См. статью [Тестирование приложения для Windows на Windows 10 S](desktop-to-uwp-test-windows-s.md).

## <a name="next-steps"></a>Дальнейшие действия

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](https://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).

**Создание пакета приложения Windows для классического приложения**

См. раздел [Создание пакета приложения для Windows](desktop-to-uwp-root.md#convert).
